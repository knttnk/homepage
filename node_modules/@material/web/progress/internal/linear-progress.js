/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import { __decorate } from "tslib";
import { html } from 'lit';
import { property, query, state } from 'lit/decorators.js';
import { styleMap } from 'lit/directives/style-map.js';
import { Progress } from './progress.js';
/**
 * A linear progress component.
 */
export class LinearProgress extends Progress {
    constructor() {
        super(...arguments);
        /**
         * Buffer amount to display, a fraction between 0 and 1.
         */
        this.buffer = 1;
        this.animationReady = true;
        this.resizeObserver = null;
    }
    getRenderClasses() {
        return {
            ...super.getRenderClasses(),
            'animation-ready': this.animationReady,
        };
    }
    // Note, the indeterminate animation is rendered with transform %'s
    // Previously, this was optimized to use px calculated with the resizeObserver
    // due to a now fixed Chrome bug: crbug.com/389359.
    renderIndicator() {
        const progressStyles = {
            transform: `scaleX(${(this.indeterminate ? 1 : this.value / this.max) * 100}%)`
        };
        const bufferStyles = {
            transform: `scaleX(${(this.indeterminate ? 1 : this.buffer / this.max) * 100}%)`
        };
        return html `
      <div class="track"></div>
      <div class="buffer-bar" style=${styleMap(bufferStyles)}></div>
      <div class="bar primary-bar" style=${styleMap(progressStyles)}>
        <div class="bar-inner"></div>
      </div>
      <div class="bar secondary-bar">
        <div class="bar-inner"></div>
      </div>
    `;
    }
    async connectedCallback() {
        super.connectedCallback();
        // wait for rendering.
        await this.updateComplete;
        if (this.resizeObserver) {
            return;
        }
        this.resizeObserver = new ResizeObserver(() => {
            if (this.indeterminate) {
                this.restartAnimation();
            }
        });
        this.resizeObserver.observe(this.rootEl);
    }
    disconnectedCallback() {
        if (this.resizeObserver) {
            this.resizeObserver.disconnect();
            this.resizeObserver = null;
        }
        super.disconnectedCallback();
    }
    // When size changes, restart the animation
    // to avoid jank.
    async restartAnimation() {
        await this.updateComplete;
        this.animationReady = false;
        await new Promise(requestAnimationFrame);
        this.animationReady = true;
        await this.updateComplete;
    }
}
__decorate([
    property({ type: Number })
], LinearProgress.prototype, "buffer", void 0);
__decorate([
    query('.progress')
], LinearProgress.prototype, "rootEl", void 0);
__decorate([
    state()
], LinearProgress.prototype, "animationReady", void 0);
//# sourceMappingURL=linear-progress.js.map