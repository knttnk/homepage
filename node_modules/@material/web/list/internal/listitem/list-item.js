/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import { __decorate } from "tslib";
import '../../../ripple/ripple.js';
import '../../../focus/md-focus-ring.js';
import { html, LitElement, nothing } from 'lit';
import { property, query } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { html as staticHtml, literal } from 'lit/static-html.js';
import { requestUpdateOnAriaChange } from '../../../internal/aria/delegate.js';
// tslint:disable-next-line:enforce-comments-on-exported-symbols
export class ListItemEl extends LitElement {
    constructor() {
        super(...arguments);
        /**
         * The primary, headline text of the list item.
         */
        this.headline = '';
        /**
         * The one-line supporting text below the headline. Set
         * `multiLineSupportingText` to `true` to support multiple lines in the
         * supporting text.
         */
        this.supportingText = '';
        /**
         * Modifies `supportingText` to support multiple lines.
         */
        this.multiLineSupportingText = false;
        /**
         * The supporting text placed at the end of the item. Overridden by elements
         * slotted into the `end` slot.
         */
        this.trailingSupportingText = '';
        /**
         * Disables the item and makes it non-selectable and non-interactive.
         */
        this.disabled = false;
        /**
         * The tabindex of the underlying item.
         *
         * __NOTE:__ this is overridden by the keyboard behavior of `md-list` and by
         * setting `selected`.
         */
        this.itemTabIndex = -1;
        /**
         * Whether or not the element is actively being interacted with by md-list.
         * When active, tabindex is set to 0, and in some list item variants (like
         * md-list-item), focuses the underlying item.
         */
        this.active = false;
        /**
         * Sets the role of the list item. Set to 'nothing' to clear the role. This
         * property will be ignored if `href` is set since the underlying element will
         * be a native anchor tag.
         */
        this.type = 'listitem';
        /**
         * READONLY. Sets the `md-list-item` attribute on the element.
         */
        this.isListItem = true;
        /**
         * Sets the underlying `HTMLAnchorElement`'s `href` resource attribute.
         */
        this.href = '';
        /**
         * Sets the underlying `HTMLAnchorElement`'s `target` attribute when `href` is
         * set.
         */
        this.target = '';
        /**
         * Only meant to be overridden by subclassing and not by the user. This is
         * so that we have control over focus on specific variants such as disabling
         * focus on <md-autocomplete-item> but enabling it for <md-menu-item>.
         */
        this.focusOnActivation = true;
        this.isFirstUpdate = true;
    }
    willUpdate(changed) {
        if (changed.has('active') && !this.disabled) {
            if (this.active) {
                this.itemTabIndex = 0;
            }
            else if (!this.isFirstUpdate) {
                // Do not reset anything if it's the first render because user could
                // have set `itemTabIndex` manually.
                this.itemTabIndex = -1;
            }
        }
    }
    render() {
        return this.renderListItem(html `
      <div class="content-wrapper">
        ${this.renderStart()}
        ${this.renderBody()}
        ${this.renderEnd()}
        ${this.renderRipple()}
        ${this.renderFocusRing()}
      </div>
    `);
    }
    /**
     * Renders the root list item.
     *
     * @param content the child content of the list item.
     */
    renderListItem(content) {
        const isAnchor = !!this.href;
        const tag = isAnchor ? literal `a` : literal `li`;
        const role = isAnchor || this.type === 'none' ? nothing : this.type;
        const target = isAnchor && !!this.target ? this.target : nothing;
        return staticHtml `
      <${tag}
        id="item"
        tabindex=${this.disabled ? -1 : this.itemTabIndex}
        role=${role}
        aria-selected=${this.ariaSelected || nothing}
        aria-checked=${this.ariaChecked || nothing}
        class="list-item ${classMap(this.getRenderClasses())}"
        href=${this.href || nothing}
        target=${target}
        @click=${this.onClick}
        @pointerenter=${this.onPointerenter}
        @pointerleave=${this.onPointerleave}
        @keydown=${this.onKeydown}
      >${content}</${tag}>
    `;
    }
    /**
     * Handles rendering of the ripple element.
     */
    renderRipple() {
        return html `
      <md-ripple
          part="ripple"
          for="item"
          ?disabled=${this.disabled}></md-ripple>`;
    }
    /**
     * Handles rendering of the focus ring.
     */
    renderFocusRing() {
        return html `
      <md-focus-ring
          @visibility-changed=${this.onFocusRingVisibilityChanged}
          class="focus-ring"
          part="focus-ring"
          for="item"
          inward></md-focus-ring>`;
    }
    onFocusRingVisibilityChanged(e) { }
    /**
     * Classes applied to the list item root.
     */
    getRenderClasses() {
        return {
            'with-one-line': this.supportingText === '',
            'with-two-line': this.supportingText !== '' && !this.multiLineSupportingText,
            'with-three-line': this.supportingText !== '' && this.multiLineSupportingText,
            'disabled': this.disabled
        };
    }
    /**
     * The content rendered at the start of the list item.
     */
    renderStart() {
        return html `<div class="start"><slot name="start"></slot></div>`;
    }
    /**
     * Handles rendering the headline and supporting text.
     */
    renderBody() {
        const supportingText = this.supportingText !== '' ? this.renderSupportingText() : '';
        return html `<div class="body"
      ><span class="label-text">${this.headline}</span>${supportingText}</div>`;
    }
    /**
     * Renders the one-line supporting text.
     */
    renderSupportingText() {
        return html `<span
        class="supporting-text ${classMap(this.getSupportingTextClasses())}"
      >${this.supportingText}</span>`;
    }
    /**
     * Gets the classes for the supporting text node
     */
    getSupportingTextClasses() {
        return { 'supporting-text--multi-line': this.multiLineSupportingText };
    }
    /**
     * The content rendered at the end of the list item.
     */
    renderEnd() {
        const supportingText = this.trailingSupportingText !== '' ?
            this.renderTrailingSupportingText() :
            '';
        return html `<div class="end"
      ><slot name="end">${supportingText}</slot></div>`;
    }
    /**
     * Renders the supporting text at the end of the list item.
     */
    renderTrailingSupportingText() {
        return html `<span class="trailing-supporting-text"
      >${this.trailingSupportingText}</span>`;
    }
    updated(changed) {
        super.updated(changed);
        // will focus the list item root if it is selected but not on the first
        // update or else it may cause the page to jump on first load.
        if (changed.has('active') && !this.isFirstUpdate && this.active &&
            this.focusOnActivation) {
            this.focus();
        }
        this.isFirstUpdate = false;
    }
    focus() {
        this.listItemRoot?.focus?.();
    }
}
(() => {
    requestUpdateOnAriaChange(ListItemEl);
})();
__decorate([
    property()
], ListItemEl.prototype, "headline", void 0);
__decorate([
    property({ attribute: 'supporting-text' })
], ListItemEl.prototype, "supportingText", void 0);
__decorate([
    property({ type: Boolean, attribute: 'multi-line-supporting-text' })
], ListItemEl.prototype, "multiLineSupportingText", void 0);
__decorate([
    property({ attribute: 'trailing-supporting-text' })
], ListItemEl.prototype, "trailingSupportingText", void 0);
__decorate([
    property({ type: Boolean })
], ListItemEl.prototype, "disabled", void 0);
__decorate([
    property({ type: Number, attribute: 'item-tabindex' })
], ListItemEl.prototype, "itemTabIndex", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], ListItemEl.prototype, "active", void 0);
__decorate([
    property()
], ListItemEl.prototype, "type", void 0);
__decorate([
    property({ type: Boolean, attribute: 'md-list-item', reflect: true })
], ListItemEl.prototype, "isListItem", void 0);
__decorate([
    property()
], ListItemEl.prototype, "href", void 0);
__decorate([
    property()
], ListItemEl.prototype, "target", void 0);
__decorate([
    query('.list-item')
], ListItemEl.prototype, "listItemRoot", void 0);
//# sourceMappingURL=list-item.js.map