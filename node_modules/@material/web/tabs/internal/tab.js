/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import { __decorate } from "tslib";
import '../../elevation/elevation.js';
import '../../focus/md-focus-ring.js';
import '../../ripple/ripple.js';
import { html, isServer, LitElement, nothing } from 'lit';
import { property, query, queryAssignedElements, queryAssignedNodes, state } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { polyfillElementInternalsAria, setupHostAria } from '../../internal/aria/aria.js';
import { EASING } from '../../internal/motion/animation.js';
/**
 * Tab component.
 */
export class Tab extends LitElement {
    constructor() {
        super();
        /**
         * Whether or not the tab is `selected`.
         **/
        this.selected = false;
        /**
         * In SSR, set this to true when an icon is present.
         */
        this.hasIcon = false;
        /**
         * In SSR, set this to true when there is no label and only an icon.
         */
        this.iconOnly = false;
        this.fullWidthIndicator = false;
        this.internals = polyfillElementInternalsAria(this, this /* needed for closure */.attachInternals());
        if (!isServer) {
            this.internals.role = 'tab';
            this.addEventListener('keydown', this.handleKeydown.bind(this));
        }
    }
    render() {
        const indicator = html `<div class="indicator"></div>`;
        return html `
      <div class="button" role="presentation">
        <md-focus-ring part="focus-ring" inward
            .control=${this}></md-focus-ring>
        <md-elevation></md-elevation>
        <md-ripple .control=${this}></md-ripple>
        <div class="content ${classMap(this.getContentClasses())}"
            role="presentation">
          <slot name="icon" @slotchange=${this.handleIconSlotChange}></slot>
          <slot @slotchange=${this.handleSlotChange}></slot>
          ${this.fullWidthIndicator ? nothing : indicator}
        </div>
        ${this.fullWidthIndicator ? indicator : nothing}
      </div>`;
    }
    getContentClasses() {
        return {
            'has-icon': this.hasIcon,
            'has-label': !this.iconOnly,
        };
    }
    updated(changed) {
        if (changed.has('selected')) {
            this.internals.ariaSelected = String(this.selected);
            this.animateSelected();
        }
    }
    async handleKeydown(event) {
        // Allow event to bubble.
        await 0;
        if (event.defaultPrevented) {
            return;
        }
        if (event.key === 'Enter' || event.key === ' ') {
            // Prevent default behavior such as scrolling when pressing spacebar.
            event.preventDefault();
            this.click();
        }
    }
    animateSelected() {
        this.indicator.getAnimations().forEach(a => {
            a.cancel();
        });
        const frames = this.getKeyframes();
        if (frames !== null) {
            this.indicator.animate(frames, { duration: 250, easing: EASING.EMPHASIZED });
        }
    }
    getKeyframes() {
        const reduceMotion = shouldReduceMotion();
        if (!this.selected) {
            return reduceMotion ? [{ 'opacity': 1 }, { 'transform': 'none' }] : null;
        }
        // TODO(b/298105040): avoid hardcoding selector
        const tabs = this.closest('md-tabs');
        const from = {};
        const fromRect = (tabs?.previousSelectedItem?.indicator.getBoundingClientRect() ??
            {});
        const fromPos = fromRect.left;
        const fromExtent = fromRect.width;
        const toRect = this.indicator.getBoundingClientRect();
        const toPos = toRect.left;
        const toExtent = toRect.width;
        const scale = fromExtent / toExtent;
        if (!reduceMotion && fromPos !== undefined && toPos !== undefined &&
            !isNaN(scale)) {
            from['transform'] = `translateX(${(fromPos - toPos).toFixed(4)}px) scaleX(${scale.toFixed(4)})`;
        }
        else {
            from['opacity'] = 0;
        }
        // note, including `transform: none` avoids quirky Safari behavior
        // that can hide the animation.
        return [from, { 'transform': 'none' }];
    }
    handleSlotChange() {
        this.iconOnly = false;
        // Check if there's any label text or elements. If not, then there is only
        // an icon.
        for (const node of this.assignedDefaultNodes) {
            const hasTextContent = node.nodeType === Node.TEXT_NODE &&
                !!node.wholeText.match(/\S/);
            if (node.nodeType === Node.ELEMENT_NODE || hasTextContent) {
                return;
            }
        }
        this.iconOnly = true;
    }
    handleIconSlotChange() {
        this.hasIcon = this.assignedIcons.length > 0;
    }
}
(() => {
    setupHostAria(Tab);
})();
__decorate([
    property({ type: Boolean, reflect: true })
], Tab.prototype, "selected", void 0);
__decorate([
    property({ type: Boolean, attribute: 'has-icon' })
], Tab.prototype, "hasIcon", void 0);
__decorate([
    property({ type: Boolean, attribute: 'icon-only' })
], Tab.prototype, "iconOnly", void 0);
__decorate([
    query('.indicator')
], Tab.prototype, "indicator", void 0);
__decorate([
    state()
], Tab.prototype, "fullWidthIndicator", void 0);
__decorate([
    queryAssignedNodes({ flatten: true })
], Tab.prototype, "assignedDefaultNodes", void 0);
__decorate([
    queryAssignedElements({ slot: 'icon', flatten: true })
], Tab.prototype, "assignedIcons", void 0);
function shouldReduceMotion() {
    return window.matchMedia('(prefers-reduced-motion: reduce)').matches;
}
//# sourceMappingURL=tab.js.map